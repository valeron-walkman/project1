"use strict";
var decorator_parser_1 = require('./decorator-parser');
var descriptions_1 = require('./descriptions');
var test_classes_spec_1 = require('./test-classes.spec');
describe('rest-serviceDescription-parser', function () {
    var bookService = new test_classes_spec_1.BookService();
    var serviceDescription = decorator_parser_1.ServiceParser.parse(bookService);
    it('should create a ServiceDescription from the service', function () {
        expect(serviceDescription).not.toBeNull();
    });
    it('should have a base path', function () {
        expect(serviceDescription.basePath).toBe('/books');
    });
    it('should have a permitAll decorator', function () {
        expect(serviceDescription.permitAll).toBe(true);
    });
    it('should have 6 methods decorated with a httpMethod', function () {
        expect(serviceDescription.methods.length).toBe(6);
    });
    describe('allBooks method', function () {
        var method = serviceDescription.getMethodDescriptorForMethodName('allBooks');
        it('should be a GET method', function () {
            expect(method.httpMethod).toBe(descriptions_1.HttpMethod.GET);
        });
        it('should have no Path', function () {
            expect(method.path).toBeNull();
        });
        it('should have two roles that are permitted to access the method', function () {
            expect(method.rolesAllowed.length).toBe(2);
            expect(method.rolesAllowed).toContain('admin');
            expect(method.rolesAllowed).toContain('user');
        });
        it('should have no PathParams', function () {
            expect(method.pathParams.length).toBe(0);
        });
        it('should have no HeaderParams', function () {
            expect(method.headerParams.length).toBe(0);
        });
        it('just for fun the method resturns an empty arry', function () {
            expect(bookService[method.methodName]()).toEqual([]);
        });
    });
    describe('deleteBook method', function () {
        var method = serviceDescription.getMethodDescriptorForMethodName('deleteBook');
        it('should be a DELETE method', function () {
            expect(method.httpMethod).toBe(descriptions_1.HttpMethod.DELETE);
        });
        it('should have a path with id', function () {
            expect(method.path).toBe('/:id');
        });
        it('should have one PathParams', function () {
            expect(method.pathParams.length).toBe(1);
            expect(method.pathParams).toContain({ paramName: 'id', index: 0 });
        });
        it('should have one QueryParams', function () {
            expect(method.queryParams.length).toBe(1);
            expect(method.queryParams).toContain({ paramName: 'time', index: 1 });
        });
        it('should have no HeaderParams', function () {
            expect(method.headerParams.length).toBe(0);
        });
        it('just for fun the method resturns true', function () {
            expect(bookService[method.methodName]()).toEqual(true);
        });
    });
    describe('updateBook methods', function () {
        var method = serviceDescription.getMethodDescriptorForMethodName('updateBook');
        it('should be a PUT method', function () {
            expect(method.httpMethod).toBe(descriptions_1.HttpMethod.PUT);
        });
        it('should have a path with id and name', function () {
            expect(method.path).toBe('/:id/:name');
        });
        it('should have two PathParams', function () {
            expect(method.pathParams.length).toBe(2);
            expect(method.pathParams).toContain({ paramName: 'id', index: 0 });
            expect(method.pathParams).toContain({ paramName: 'name', index: 1 });
        });
        it('should have no HeaderParams', function () {
            expect(method.headerParams.length).toBe(0);
        });
        it('just for fun the method resturns what is provided', function () {
            expect(bookService[method.methodName](1, 'name')).toEqual({ 'id': 1, 'name': 'name' });
        });
    });
    describe('createBook method', function () {
        var method = serviceDescription.getMethodDescriptorForMethodName('createBook');
        it('should be a POST method', function () {
            expect(method.httpMethod).toBe(descriptions_1.HttpMethod.POST);
        });
        it('should be permitted for all', function () {
            expect(method.permitAll).toBe(true);
        });
        it('should have a path with name', function () {
            expect(method.path).toBe('/:name');
        });
        it('should have one PathParams', function () {
            expect(method.pathParams.length).toBe(1);
            expect(method.pathParams).toContain({ paramName: 'name', index: 0 });
        });
        it('should have one HeaderParams', function () {
            expect(method.headerParams.length).toBe(1);
            expect(method.headerParams).toContain({ paramName: 'token', index: 1 });
        });
        it('just for fun the method resturns what is provided', function () {
            expect(bookService[method.methodName]('name')).toEqual({ 'id': 1, 'name': 'name' });
        });
    });
    describe('contextTest method', function () {
        var method = serviceDescription.getMethodDescriptorForMethodName('contextTest');
        it('should have one ContextParam', function () {
            expect(method.contextParams.length).toBe(2);
            expect(method.contextParams).toContain({ paramName: 'HttpRequest', index: 0 });
            expect(method.contextParams).toContain({ paramName: 'HttpResponse', index: 1 });
        });
    });
    describe('security context test method', function () {
        var method = serviceDescription.getMethodDescriptorForMethodName('securityContextTest');
        it('should have one SecurityContextParam', function () {
            expect(method.securityContextParam).toEqual({ paramName: 'SecurityContext', index: 0 });
        });
    });
});
//# sourceMappingURL=decorator-parser.spec.js.map