"use strict";
var namings = require('./namings');
var descriptions_1 = require('./descriptions');
var decoratorUtil_1 = require('./decoratorUtil');
function createHttpMethodFunction(httpMethod) {
    return function (target, key, descriptor) {
        Reflect.defineMetadata(namings.httpMethodMarker, httpMethod, descriptor.value);
    };
}
/**
 * Publish a method as an http endpoint for GET requests. If no Path is specified the path will be /.
 * The decorator is only allowed on methods.
 * @returns the decorated function
 */
function GET() { return createHttpMethodFunction(descriptions_1.HttpMethod.GET); }
exports.GET = GET;
/**
 * Publish a method as an http endpoint for POST requests. If no Path is specified the path will be /.
 * The decorator is only allowed on methods.
 * @returns the decorated function
 */
function POST() { return createHttpMethodFunction(descriptions_1.HttpMethod.POST); }
exports.POST = POST;
/**
 * Publish a method as an http endpoint for PUT requests. If no Path is specified the path will be /.
 * The decorator is only allowed on methods.
 * @returns the decorated function
 */
function PUT() { return createHttpMethodFunction(descriptions_1.HttpMethod.PUT); }
exports.PUT = PUT;
/**
 * Publish a method as an http endpoint for DELETE requests. If no Path is specified the path will be /.
 * The decorator is only allowed on methods.
 * @returns the decorated function
 */
function DELETE() { return createHttpMethodFunction(descriptions_1.HttpMethod.DELETE); }
exports.DELETE = DELETE;
/**
 * Specify the Path for the ressource. If the decorator is present at class level all methods paths will be
 * prefixed with this path.
 * @param path The path for the class or method. The path must not be start with /.
 * The slash will be added automatically.
 * @returns the decorated function
 */
function Path(path) {
    return decoratorUtil_1.DecoratorUtil.decorateClassOrMethod(namings.path, path);
}
exports.Path = Path;
/**
 * Specifies how a method parameter is evealuated. In this case the value will be taken
 * from the parameter that is specified in the path decorator.
 * @param name the name in the path that should be used to provide the parameter to the method.
 * @returns the decorated function
 */
function PathParam(name) { return decoratorUtil_1.DecoratorUtil.createParamDecorator(name, namings.pathParam); }
exports.PathParam = PathParam;
/**
 * Specifies how a method parameter is evaluated. In this case the value will be taken
 * from a http header.
 * @param name the name in the http header that should be used to provide the parameter to the method.
 * @returns the decorated function
 */
function HeaderParam(name) { return decoratorUtil_1.DecoratorUtil.createParamDecorator(name, namings.headerParam); }
exports.HeaderParam = HeaderParam;
/**
 * Specifies how a method parameter is evaluated. In this case the value will be taken
 * from a url query parameter.
 * @param name the name of the query param that should be used to provide the parameter to the method.
 * @returns the decorated function
 */
function QueryParam(name) { return decoratorUtil_1.DecoratorUtil.createParamDecorator(name, namings.queryParam); }
exports.QueryParam = QueryParam;
/**
 * Specifies how a method parameter is evaluated. In this case the value will be taken
 * from the context (for example the current Request).
 * @param contextType the ContextTypes that should be used to provide the parameter to the method.
 * @returns the decorated function
 */
function Context(contextType) { return decoratorUtil_1.DecoratorUtil.createParamDecorator(descriptions_1.ContextTypes[contextType], namings.contextParam); }
exports.Context = Context;
/**
 * Specifies a method parameter that is a ISecurityContext
 * @returns the decorated function
 */
function SecurityContext() {
    return function (target, propertyKey, parameterIndex) {
        Reflect.defineMetadata(namings.securityContextParam, { paramName: "SecurityContext", index: parameterIndex }, target, propertyKey);
    };
}
exports.SecurityContext = SecurityContext;
;
function PermitAll() {
    return decoratorUtil_1.DecoratorUtil.decorateClassOrMethod(namings.permitAll, true);
}
exports.PermitAll = PermitAll;
function RolesAllowed(roles) {
    return decoratorUtil_1.DecoratorUtil.decorateClassOrMethod(namings.rolesAllowed, roles);
}
exports.RolesAllowed = RolesAllowed;
//# sourceMappingURL=decorators.js.map